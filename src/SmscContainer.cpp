/*
* ============================================================================
*  Name     : CSmscContainer from SmscContainer.h
*  Part of  : Smsc
*  Created  : 30/7/2003 by Makidis Michael
*  Implementation notes:
*     Initial content was generated by Series 60 AppWizard.
*  Copyright: Makidis Michael 2003-2004
* ============================================================================
*/

// INCLUDE FILES
#include "SmscContainer.h"
#include <aknnotewrappers.h> // for note
#include <Smsc.rsg>
#include <aknpopup.h>  // for popup list
#include <stringloader.h>  // for StringLoader

// ================= MEMBER FUNCTIONS =======================

CSmscContainer::CSmscContainer ( CSmscView* aView):iListBox(NULL),
 iView(aView), iTextArray(NULL)
{};

// ---------------------------------------------------------
// CSmscContainer::ConstructL(const TRect& aRect)
// EPOC two phased constructor
// ---------------------------------------------------------
//
void CSmscContainer::ConstructL(const TRect& aRect)
    {
    CreateWindowL();
    SetRect(aRect);

	// Delete listbox object.
    if ( iListBox )
        {
        delete iListBox;
        iListBox = NULL;
        }

	// Create a new listbox
	iListBox = new ( ELeave ) CAknDoubleStyleListBox();
	iListBox->SetContainerWindowL( *this );

	// Construct listbox.
	if ( iListBox )
        iListBox->ConstructL( this, EAknListBoxSelectionList);

	// Set the model...
	iTextArray = new(ELeave) CDesCArraySeg(5);
	if ( iTextArray && iListBox )
		{
		// Sets list items
		iListBox->Model()->SetItemTextArray( iTextArray );
		iListBox->Model()->SetOwnershipType( ELbmDoesNotOwnItemArray );
		}

	// Create scrollbar.
	if ( iListBox )
    {
		// Creates scrollbar.
		iListBox->CreateScrollBarFrameL( ETrue );
		iListBox->ScrollBarFrame()->SetScrollBarVisibilityL(
		CEikScrollBarFrame::EOff, CEikScrollBarFrame::EAuto );
	}
	
	// Empty listbox message
	HBufC* textResource = StringLoader::LoadLC(R_NO_MESSAGES);
	iListBox->View()->SetListEmptyTextL(*textResource);
	iListBox->DrawNow();
	CleanupStack::PopAndDestroy(textResource);

	// Display listbox
	iListBox->SetListBoxObserver( this );
	SizeChanged();
	iListBox->ActivateL();

	// update scroll bar
    if (iListBox)
        {   
        TInt pos(iListBox->View()->CurrentItemIndex());
        if (iListBox->ScrollBarFrame())
            {
            iListBox->ScrollBarFrame()->MoveVertThumbTo(pos);
            }
        }

	ActivateL();

	// Open the channel to the messages services
	iMsvSession = CMsvSession::OpenSyncL(*this);
	iMtmReg = CClientMtmRegistry::NewL(*iMsvSession);
	iSmsMtm = (CSmsClientMtm*) iMtmReg->NewMtmL( KUidMsgTypeSMS );

	iMsvidArray = new(ELeave)CArrayFixSeg<TMsvId>(4);

	// Populate the list
	RefreshListL();
    }

// Destructor
CSmscContainer::~CSmscContainer()
    {
	delete iListBox; // Deletes listbox object.
	delete iTextArray;
	delete iMsvidArray;

	delete iSmsMtm;
	delete iMtmReg;
	delete iMsvSession;    // session must be deleted last (and constructed first)
    }

void CSmscContainer::RefreshListL(TBool aRedrawOnceOnly)
{
	ClearListL(!aRedrawOnceOnly);

	// select the Inbox index to start the search
	CMsvEntry* currentEntry = iMsvSession->GetEntryL(KMsvGlobalInBoxIndexEntryId);

	CleanupStack::PushL(currentEntry);

	// sort the entries
	currentEntry->SetSortTypeL(TMsvSelectionOrdering
		(KMsvGroupByType, EMsvSortByDateReverse, EFalse));
	
	const TInt count = currentEntry->Count();
	TInt Smss = 0;

	TBuf<200> text;
	TBuf<30> dateString;

	for(TInt i = 0; i < count; i++)
	{
		const TMsvEntry& child = (*currentEntry)[i];
		// is it an sms?
		if(child.iMtm == KUidMsgTypeSMS)
		{
			Smss++;

			// Store the id
			iMsvidArray->AppendL(child.Id());

			// Load the message
			iSmsMtm->SwitchCurrentEntryL(child.Id());
			iSmsMtm->LoadMessageL();

			// First txt position of the item (empty)
			text.Append(_L(" \t"));

			// Second position (sender)
			text.Append(child.iDetails);

			// Third Position
			// SMSC
			text.Append(_L("\tC:"));
			text.Append(iSmsMtm->SmsHeader().ServiceCenterAddress());
			// Date & Time
			text.Append(_L("@"));
			child.iDate.FormatL(dateString, _L("%M%Y%/0%4%/1%5%/3"));
			text.Append(dateString);
			text.Append(_L(" "));
			child.iDate.FormatL(dateString, _L("%-B%:0%J%:1%T%:3%+B"));
			text.Append(dateString);

			// Done - append the item
			iTextArray->AppendL(text);

			// Redraw
			if(!aRedrawOnceOnly)
			{
				iListBox->HandleItemAdditionL(); // will redraw if necessery
				if(Smss == 3) iListBox->DrawNow(); // always draw the first 3 ;)
			}

			// Clear the txt
			text = _L("");
		}
	}

	iListBox->ScrollToMakeItemVisible(iListBox->CurrentItemIndex());
	if(aRedrawOnceOnly && iListBox->Model()->NumberOfItems() != 0) 
		iListBox->HandleItemAdditionL();

	CleanupStack::PopAndDestroy(currentEntry);
}

// ---------------------------------------------------------
// CSmscContainer::SizeChanged()
// Called by framework when the view size is changed
// ---------------------------------------------------------
//
void CSmscContainer::SizeChanged()
    {
	    if ( iListBox )
        {
        iListBox->SetRect( Rect() ); // Sets rectangle of lstbox.
        }
    }

// ---------------------------------------------------------
// CSmscContainer::CountComponentControls() const
// ---------------------------------------------------------
//
TInt CSmscContainer::CountComponentControls() const
    {
    if(iListBox) return 1; // return nbr of controls inside this container
	else return 0;
    }

// ---------------------------------------------------------
// CSmscContainer::ComponentControl(TInt aIndex) const
// ---------------------------------------------------------
//
CCoeControl* CSmscContainer::ComponentControl(TInt /*aIndex*/) const
    {
    if(iListBox) return iListBox; // return nbr of controls inside this container
	else return 0;
    }

// ---------------------------------------------------------
// CSmscContainer::Draw(const TRect& aRect) const
// ---------------------------------------------------------
//
void CSmscContainer::Draw(const TRect& /*aRect*/) const
    {
	// Nothing to draw - we display a listbox only

    /*CWindowGc& gc = SystemGc();
    gc.SetPenStyle(CGraphicsContext::ENullPen);
    gc.SetBrushColor(KRgbGray);
    gc.SetBrushStyle(CGraphicsContext::ESolidBrush);
    gc.DrawRect(aRect);*/
    }

// ----------------------------------------------------------------------------
// TKeyResponse CSmscContainer::OfferKeyEventL( const TKeyEvent&,
//  TEventCode )
// Handles the key events.
// ----------------------------------------------------------------------------
//
TKeyResponse CSmscContainer::OfferKeyEventL(
    const TKeyEvent& aKeyEvent,
    TEventCode aType )
    {
    if ( aType != EEventKey ) // Is not key event?
        {
        return EKeyWasNotConsumed;
        }

    switch ( aKeyEvent.iCode ) // The code of key event is...
        {
		case EKeyLeftArrow: // Left key.
        case EKeyRightArrow: // Right Key.
			return EKeyWasNotConsumed;
            break;
		case EKeyEnter:
		case EKeyOK:
			ShowDetailsL();
			return EKeyWasConsumed;
			break;
        default:
			if ( iListBox )
				return iListBox->OfferKeyEventL( aKeyEvent, aType );
			else
				return EKeyWasNotConsumed;
            break;
        }
    }

// ---------------------------------------------------------
// CSmscContainer::HandleControlEventL(
//     CCoeControl* aControl,TCoeEvent aEventType)
// ---------------------------------------------------------
//
void CSmscContainer::HandleControlEventL(
    CCoeControl* /*aControl*/,TCoeEvent /*aEventType*/)
    {
    // No need to add any control event handler code here
    }

void CSmscContainer::ClearListL(TBool aRedraw)
{
	iTextArray->Reset();
	iMsvidArray->Reset();
	iListBox->HandleItemRemovalL();
	if(aRedraw) iListBox->DrawNow();
}

void CSmscContainer::HandleSessionEventL
			(TMsvSessionEvent aEvent, TAny* /*aArg1*/, TAny* /*aArg2*/, TAny* /*aArg3*/)
{
	if(
		aEvent == EMsvMtmGroupInstalled ||
		aEvent == EMsvMtmGroupDeInstalled ||
		aEvent == EMsvCloseSession ||
		aEvent == EMsvCorruptedIndexRebuilt ||
		aEvent == EMsvServerTerminated ||
		aEvent == EMsvMediaChanged ||
		aEvent == EMsvMediaUnavailable ||
		aEvent == EMsvGeneralError ||
		aEvent == EMsvCorruptedIndexRebuilding
		)
	{
		delete iSmsMtm;
		delete iMtmReg;
		delete iMsvSession;    // session must be deleted last (and constructed first)

		iMsvSession = CMsvSession::OpenSyncL(*this);
		iMtmReg = CClientMtmRegistry::NewL(*iMsvSession);
		iSmsMtm = (CSmsClientMtm*) iMtmReg->NewMtmL( KUidMsgTypeSMS );

		RefreshListL(ETrue);
	}
	else
		RefreshListL(ETrue);
}

void CSmscContainer::ShowDetailsL()
{
	if(iListBox->Model()->NumberOfItems() == 0)
	{
		// inform the users that there are no messages
		HBufC* textResource = StringLoader::LoadLC(R_NO_MESSAGES_SELECTED);
		CAknInformationNote* note = new (ELeave) CAknInformationNote();
		note->ExecuteLD(*textResource);
		CleanupStack::PopAndDestroy(textResource);
		return;
	}

	// Create listbox and PUSH it.
    CEikTextListBox* list = new(ELeave) CAknSingleHeadingPopupMenuStyleListBox;
    CleanupStack::PushL(list);

    // Create popup list and PUSH it.
    CAknPopupList* popupList = CAknPopupList::NewL(
                                        list, R_AVKON_SOFTKEYS_BACK,
                                        AknPopupLayouts::EMenuWindow);
    CleanupStack::PushL(popupList);

    // initialize listbox.
    list->ConstructL(popupList, CEikListBox::ELeftDownInViewRect | EAknListBoxViewerFlag);
    list->CreateScrollBarFrameL(ETrue);
    list->ScrollBarFrame()->SetScrollBarVisibilityL(
                                CEikScrollBarFrame::EOff,
                                CEikScrollBarFrame::EAuto);

	// Set title
	HBufC* textResource = StringLoader::LoadLC(R_DETAILS_TITLE);
    popupList->SetTitleL(*textResource);
	CleanupStack::PopAndDestroy(textResource);

	// Load the selected message
	CMsvEntry* currentEntry = iMsvSession->GetEntryL((*iMsvidArray)[iListBox->CurrentItemIndex()]);
	CleanupStack::PushL(currentEntry);
	const TMsvEntry& entry = currentEntry->Entry();
	iSmsMtm->SwitchCurrentEntryL(entry.Id());
	iSmsMtm->LoadMessageL();


	// Get the info
	TBuf<50> text;
	TBuf<30> dateString;
	CDesCArray* items = new(ELeave) CDesCArraySeg(5);

	// From
	textResource = StringLoader::LoadLC(R_DETAILS_FROM);
	text.Append(*textResource);
	text.Append(_L("\t"));
	text.Append(entry.iDetails);
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);


	// Tel No
	text.Zero();
	textResource = StringLoader::LoadLC(R_DETAILS_TELNO);
	text.Append(*textResource);
	text.Append(_L("\t"));
	text.Append(iSmsMtm->SmsHeader().Message().ToFromAddress());
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);

	// SMSC
	text.Zero();
	textResource = StringLoader::LoadLC(R_DETAILS_SMSC);
	text.Append(*textResource);
	text.Append(_L("\t"));
	text.Append(iSmsMtm->SmsHeader().ServiceCenterAddress());
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);

	//Subject
	text.Zero();
	textResource = StringLoader::LoadLC(R_DETAILS_SUBJECT);
	text.Append(*textResource);
	text.Append(_L("\t"));
	text.Append(entry.iDescription);
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);

	// Date
	text.Zero();
	textResource = StringLoader::LoadLC(R_DETAILS_DATE);
	text.Append(*textResource);
	text.Append(_L("\t"));
	entry.iDate.FormatL(dateString, _L("%D%M%Y%/0%1%/1%2%/2%3%/3"));
	text.Append(dateString);
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);

	// Time
	text.Zero();
	textResource = StringLoader::LoadLC(R_DETAILS_TIME);
	text.Append(*textResource);
	text.Append(_L("\t"));
	entry.iDate.FormatL(dateString, _L("%-B%:0%J%:1%T%:3%+B"));
	text.Append(dateString);
	items->AppendL(text);
	CleanupStack::PopAndDestroy(textResource);

	CleanupStack::PopAndDestroy(currentEntry);

    // Set listitems.
    list->Model()->SetItemTextArray(items);
    list->Model()->SetOwnershipType(ELbmOwnsItemArray);

    // Show popup list
    popupList->ExecuteLD();
    CleanupStack::Pop();            // popuplist

    CleanupStack::PopAndDestroy();  // list
}

// End of File  